/*
 * ex: set ro:
 * DO NOT EDIT.
 * generated by smc (http://smc.sourceforge.net/)
 * from file : AppClass.sm
 */

#include "AppClass.h"
#include "AppClass_sm.h"

#define getOwner(fsm) \
    (fsm)->_owner

#define POPULATE_STATE(state) \
    state##_EOS, \
    state##_One, \
    state##_Unknown, \
    state##_Zero, \
    state##_Default

#define ENTRY_STATE(state)

#define EXIT_STATE(state)

static void AppClassState_EOS(struct AppClassContext *fsm)
{
    getState(fsm)->Default(fsm);
}

static void AppClassState_One(struct AppClassContext *fsm)
{
    getState(fsm)->Default(fsm);
}

static void AppClassState_Unknown(struct AppClassContext *fsm)
{
    getState(fsm)->Default(fsm);
}

static void AppClassState_Zero(struct AppClassContext *fsm)
{
    getState(fsm)->Default(fsm);
}

static void AppClassState_Default(struct AppClassContext *fsm)
{
    if (getDebugFlag(fsm) != 0) {
        TRACE("TRANSITION   : %s.%s\n", getName(getState(fsm)), getTransition(fsm));
    }
    State_Default(fsm);
}

#define Map1_Start_EOS AppClassState_EOS
#define Map1_Start_One AppClassState_One
#define Map1_Start_Unknown AppClassState_Unknown
#define Map1_Start_Zero AppClassState_Zero
#define Map1_Start_Default AppClassState_Default
#define Map1_Start_Entry NULL
#define Map1_Start_Exit NULL
#define Map1_Zeros_EOS AppClassState_EOS
#define Map1_Zeros_One AppClassState_One
#define Map1_Zeros_Unknown AppClassState_Unknown
#define Map1_Zeros_Zero AppClassState_Zero
#define Map1_Zeros_Default AppClassState_Default
#define Map1_Zeros_Entry NULL
#define Map1_Zeros_Exit NULL
#define Map1_Ones_EOS AppClassState_EOS
#define Map1_Ones_One AppClassState_One
#define Map1_Ones_Unknown AppClassState_Unknown
#define Map1_Ones_Zero AppClassState_Zero
#define Map1_Ones_Default AppClassState_Default
#define Map1_Ones_Entry NULL
#define Map1_Ones_Exit NULL
#define Map1_OK_EOS AppClassState_EOS
#define Map1_OK_One AppClassState_One
#define Map1_OK_Unknown AppClassState_Unknown
#define Map1_OK_Zero AppClassState_Zero
#define Map1_OK_Default AppClassState_Default
#define Map1_OK_Entry NULL
#define Map1_OK_Exit NULL
#define Map1_Error_EOS AppClassState_EOS
#define Map1_Error_One AppClassState_One
#define Map1_Error_Unknown AppClassState_Unknown
#define Map1_Error_Zero AppClassState_Zero
#define Map1_Error_Default AppClassState_Default
#define Map1_Error_Entry NULL
#define Map1_Error_Exit NULL
#define Map1_DefaultState_EOS AppClassState_EOS
#define Map1_DefaultState_One AppClassState_One
#define Map1_DefaultState_Unknown AppClassState_Unknown
#define Map1_DefaultState_Zero AppClassState_Zero

#undef Map1_Start_Unknown
#define Map1_Start_Unknown Map1_DefaultState_Unknown
#undef Map1_Zeros_Unknown
#define Map1_Zeros_Unknown Map1_DefaultState_Unknown
#undef Map1_Ones_Unknown
#define Map1_Ones_Unknown Map1_DefaultState_Unknown
#undef Map1_OK_Unknown
#define Map1_OK_Unknown Map1_DefaultState_Unknown
#undef Map1_Error_Unknown
#define Map1_Error_Unknown Map1_DefaultState_Unknown
#undef Map1_DefaultState_Unknown
static void Map1_DefaultState_Unknown(struct AppClassContext *fsm)
{

    if (getDebugFlag(fsm) != 0) {
        TRACE("LEAVING STATE   : Map1_DefaultState)\n");
    }
    EXIT_STATE(getState(fsm));
    if (getDebugFlag(fsm) != 0) {
        TRACE("ENTER TRANSITION: Map1_&Map1_DefaultState.Unknown()\n");
    }
    if (getDebugFlag(fsm) != 0) {
        TRACE("EXIT TRANSITION : Map1_&Map1_DefaultState.Unknown()\n");
    }
    setState(fsm, &Map1_Error);
    ENTRY_STATE(getState(fsm));
}

#undef Map1_Start_EOS
static void Map1_Start_EOS(struct AppClassContext *fsm)
{
    struct AppClass* ctxt = getOwner(fsm);

    if (getDebugFlag(fsm) != 0) {
        TRACE("LEAVING STATE   : Map1_Start)\n");
    }
    EXIT_STATE(getState(fsm));
    if (getDebugFlag(fsm) != 0) {
        TRACE("ENTER TRANSITION: Map1_&Map1_Start.EOS()\n");
    }
    clearState(fsm);
    AppClass_Acceptable(ctxt);
    if (getDebugFlag(fsm) != 0) {
        TRACE("EXIT TRANSITION : Map1_&Map1_Start.EOS()\n");
    }
    setState(fsm, &Map1_OK);
    ENTRY_STATE(getState(fsm));
}

#undef Map1_Start_One
static void Map1_Start_One(struct AppClassContext *fsm)
{

    if (getDebugFlag(fsm) != 0) {
        TRACE("LEAVING STATE   : Map1_Start)\n");
    }
    EXIT_STATE(getState(fsm));
    if (getDebugFlag(fsm) != 0) {
        TRACE("ENTER TRANSITION: Map1_&Map1_Start.One()\n");
    }
    if (getDebugFlag(fsm) != 0) {
        TRACE("EXIT TRANSITION : Map1_&Map1_Start.One()\n");
    }
    setState(fsm, &Map1_Ones);
    ENTRY_STATE(getState(fsm));
}

#undef Map1_Start_Zero
static void Map1_Start_Zero(struct AppClassContext *fsm)
{

    if (getDebugFlag(fsm) != 0) {
        TRACE("LEAVING STATE   : Map1_Start)\n");
    }
    EXIT_STATE(getState(fsm));
    if (getDebugFlag(fsm) != 0) {
        TRACE("ENTER TRANSITION: Map1_&Map1_Start.Zero()\n");
    }
    if (getDebugFlag(fsm) != 0) {
        TRACE("EXIT TRANSITION : Map1_&Map1_Start.Zero()\n");
    }
    setState(fsm, &Map1_Zeros);
    ENTRY_STATE(getState(fsm));
}

const struct AppClassState Map1_Start = { POPULATE_STATE(Map1_Start), 0, "Map1_Start" };

#undef Map1_Zeros_EOS
static void Map1_Zeros_EOS(struct AppClassContext *fsm)
{
    struct AppClass* ctxt = getOwner(fsm);

    if (getDebugFlag(fsm) != 0) {
        TRACE("LEAVING STATE   : Map1_Zeros)\n");
    }
    EXIT_STATE(getState(fsm));
    if (getDebugFlag(fsm) != 0) {
        TRACE("ENTER TRANSITION: Map1_&Map1_Zeros.EOS()\n");
    }
    clearState(fsm);
    AppClass_Acceptable(ctxt);
    if (getDebugFlag(fsm) != 0) {
        TRACE("EXIT TRANSITION : Map1_&Map1_Zeros.EOS()\n");
    }
    setState(fsm, &Map1_OK);
    ENTRY_STATE(getState(fsm));
}

#undef Map1_Zeros_One
static void Map1_Zeros_One(struct AppClassContext *fsm)
{

    if (getDebugFlag(fsm) != 0) {
        TRACE("LEAVING STATE   : Map1_Zeros)\n");
    }
    EXIT_STATE(getState(fsm));
    if (getDebugFlag(fsm) != 0) {
        TRACE("ENTER TRANSITION: Map1_&Map1_Zeros.One()\n");
    }
    if (getDebugFlag(fsm) != 0) {
        TRACE("EXIT TRANSITION : Map1_&Map1_Zeros.One()\n");
    }
    setState(fsm, &Map1_Ones);
    ENTRY_STATE(getState(fsm));
}

#undef Map1_Zeros_Zero
static void Map1_Zeros_Zero(struct AppClassContext *fsm)
{

    if (getDebugFlag(fsm) != 0) {
        TRACE("LEAVING STATE   : Map1_Zeros)\n");
    }
    if (getDebugFlag(fsm) != 0) {
        TRACE("ENTER TRANSITION: Map1_&Map1_Zeros.Zero()\n");
    }
    if (getDebugFlag(fsm) != 0) {
        TRACE("EXIT TRANSITION : Map1_&Map1_Zeros.Zero()\n");
    }
}

const struct AppClassState Map1_Zeros = { POPULATE_STATE(Map1_Zeros), 1, "Map1_Zeros" };

#undef Map1_Ones_EOS
static void Map1_Ones_EOS(struct AppClassContext *fsm)
{
    struct AppClass* ctxt = getOwner(fsm);

    if (getDebugFlag(fsm) != 0) {
        TRACE("LEAVING STATE   : Map1_Ones)\n");
    }
    EXIT_STATE(getState(fsm));
    if (getDebugFlag(fsm) != 0) {
        TRACE("ENTER TRANSITION: Map1_&Map1_Ones.EOS()\n");
    }
    clearState(fsm);
    AppClass_Acceptable(ctxt);
    if (getDebugFlag(fsm) != 0) {
        TRACE("EXIT TRANSITION : Map1_&Map1_Ones.EOS()\n");
    }
    setState(fsm, &Map1_OK);
    ENTRY_STATE(getState(fsm));
}

#undef Map1_Ones_One
static void Map1_Ones_One(struct AppClassContext *fsm)
{

    if (getDebugFlag(fsm) != 0) {
        TRACE("LEAVING STATE   : Map1_Ones)\n");
    }
    if (getDebugFlag(fsm) != 0) {
        TRACE("ENTER TRANSITION: Map1_&Map1_Ones.One()\n");
    }
    if (getDebugFlag(fsm) != 0) {
        TRACE("EXIT TRANSITION : Map1_&Map1_Ones.One()\n");
    }
}

#undef Map1_Ones_Zero
static void Map1_Ones_Zero(struct AppClassContext *fsm)
{

    if (getDebugFlag(fsm) != 0) {
        TRACE("LEAVING STATE   : Map1_Ones)\n");
    }
    EXIT_STATE(getState(fsm));
    if (getDebugFlag(fsm) != 0) {
        TRACE("ENTER TRANSITION: Map1_&Map1_Ones.Zero()\n");
    }
    if (getDebugFlag(fsm) != 0) {
        TRACE("EXIT TRANSITION : Map1_&Map1_Ones.Zero()\n");
    }
    setState(fsm, &Map1_Error);
    ENTRY_STATE(getState(fsm));
}

const struct AppClassState Map1_Ones = { POPULATE_STATE(Map1_Ones), 2, "Map1_Ones" };

const struct AppClassState Map1_OK = { POPULATE_STATE(Map1_OK), 3, "Map1_OK" };

#undef Map1_Error_EOS
static void Map1_Error_EOS(struct AppClassContext *fsm)
{
    struct AppClass* ctxt = getOwner(fsm);
    const struct AppClassState* EndStateName = getState(fsm);

    if (getDebugFlag(fsm) != 0) {
        TRACE("LEAVING STATE   : Map1_Error)\n");
    }
    if (getDebugFlag(fsm) != 0) {
        TRACE("ENTER TRANSITION: Map1_&Map1_Error.EOS()\n");
    }
    clearState(fsm);
    AppClass_Unacceptable(ctxt);
    if (getDebugFlag(fsm) != 0) {
        TRACE("EXIT TRANSITION : Map1_&Map1_Error.EOS()\n");
    }
    setState(fsm, EndStateName);
}

#undef Map1_Error_One
static void Map1_Error_One(struct AppClassContext *fsm)
{

    if (getDebugFlag(fsm) != 0) {
        TRACE("LEAVING STATE   : Map1_Error)\n");
    }
    if (getDebugFlag(fsm) != 0) {
        TRACE("ENTER TRANSITION: Map1_&Map1_Error.One()\n");
    }
    if (getDebugFlag(fsm) != 0) {
        TRACE("EXIT TRANSITION : Map1_&Map1_Error.One()\n");
    }
}

#undef Map1_Error_Unknown
static void Map1_Error_Unknown(struct AppClassContext *fsm)
{

    if (getDebugFlag(fsm) != 0) {
        TRACE("LEAVING STATE   : Map1_Error)\n");
    }
    if (getDebugFlag(fsm) != 0) {
        TRACE("ENTER TRANSITION: Map1_&Map1_Error.Unknown()\n");
    }
    if (getDebugFlag(fsm) != 0) {
        TRACE("EXIT TRANSITION : Map1_&Map1_Error.Unknown()\n");
    }
}

#undef Map1_Error_Zero
static void Map1_Error_Zero(struct AppClassContext *fsm)
{

    if (getDebugFlag(fsm) != 0) {
        TRACE("LEAVING STATE   : Map1_Error)\n");
    }
    if (getDebugFlag(fsm) != 0) {
        TRACE("ENTER TRANSITION: Map1_&Map1_Error.Zero()\n");
    }
    if (getDebugFlag(fsm) != 0) {
        TRACE("EXIT TRANSITION : Map1_&Map1_Error.Zero()\n");
    }
}

const struct AppClassState Map1_Error = { POPULATE_STATE(Map1_Error), 4, "Map1_Error" };

/*
 * Local variables:
 *  buffer-read-only: t
 * End:
 */
